using Godot;
using MessagePack;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;


public enum RPCType
{
    ERROR,
    Chat,
    StartGame,

}

[MessagePackObject]
public class RPCPacket
{
    [Key(0)]
    public RPCType type;
    
    [Key(1)]
    public List<ulong> numericalParams;

    [Key(2)]
    public List<string> stringParams;
}

/// <summary>
/// Abandonded autogenerated RPC system using C# attributes. The better solution but I can't be assed atm
/// </summary>
//[System.AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
//public class RPCAttribute : Attribute
//{
//    RPCType type { get; set; }
//    List<Variant> paramList = new List<Variant>();

//    public RPCAttribute(RPCType type)
//    { this.type = type; }

//}


public static class RPCManager
{
    public delegate void ChatReceived(string msg, ulong sender);
    public static event ChatReceived ChatReceivedEvent;

    public static void ProcessNetCommandBytes(byte[] payload, ulong sender)
    {
        Logging.Log($"RCV: {MessagePackSerializer.ConvertToJson(payload)}", "RPCManager");
        RPCPacket packet = MessagePackSerializer.Deserialize<RPCPacket>(payload);
        Logging.Log($"RPC RCV | type:{packet.type}", "RPCManager");
        if (packet == null)
        {
            Logging.Error($"RPC Deserializer failure", "RPCManager");
        }
        switch (packet.type)
        {
            case RPCType.ERROR:
                Logging.Error($"Invalid network command received from {sender}!", "RPCManager");
                break;
            case RPCType.StartGame:
                Logging.Log($"Network command from {sender} to start game on map {packet.stringParams[0]}!", "RPCManager");
                Global.gameState.StartGame(packet.stringParams[0]);
                break;
            case RPCType.Chat:
                Logging.Log($"Network chat from {sender}!", "RPCManager");
                ChatReceivedEvent?.Invoke(packet.stringParams[0], sender);
                break;
            default:
                break;
        }
    }

    public static void NetCommand_Chat(string msg)
    {
        RPCPacket packet = new();
        packet.type = RPCType.Chat;
        packet.stringParams = new();
        packet.stringParams.Add(msg);
        byte[] payload = MessagePackSerializer.Serialize(packet);
        Logging.Log($"RPC SENT: Type=Chat, data={MessagePackSerializer.ConvertToJson(payload)}", "RPCManager");
        Global.network.BroadcastData(payload, Channel.NetCommands, Global.Lobby.lobbyPeers.ToList());
    }

    public static void NetCommand_StartGame(string scenePathOfMap)
    {
        RPCPacket packet = new();
        packet.type = RPCType.StartGame;
        packet.stringParams = new();
        packet.stringParams.Add(scenePathOfMap);
        byte[] payload = MessagePackSerializer.Serialize(packet);
        Logging.Log($"RPC SENT: Type=StartGame, data={MessagePackSerializer.ConvertToJson(payload)}", "RPCManager");
        Global.network.BroadcastData(payload,Channel.NetCommands,Global.Lobby.lobbyPeers.ToList());
    }


    
    public static void HandleRPCMessageBytes(byte[] message, ulong sender)
    {
        RPCMessage packet = MessagePackSerializer.Deserialize<RPCMessage>(message);
        ProcessRPC(packet.nodePath,packet.methodName,packet.data);
    }

    public static void ProcessRPC(NodePath path,string methodName, byte[] data)
    {
        Node node = Global.instance.GetNode(path);
        if (node == null) 
        {
            Logging.Error($"RPC Targeted invalid node: {path}","RPCManager");
        }
        Type nodeType = node.GetType();
        MethodInfo method = nodeType.GetMethod(methodName);
        if (method == null)
        {
            Logging.Error($"Node at {path} (reflection type:{nodeType.ToString()} does not have method named: {methodName}","RPCManager");
        }
        method.Invoke(node, [data]);
    }

    public static void SendRPC(NodePath path, string methodName, byte[] data)
    {
        RPCMessage packet = new();
        packet.nodePath = path;
        packet.methodName = methodName;
        packet.data = data;
        Global.network.BroadcastData(MessagePackSerializer.Serialize(packet),Channel.GenericRPC,Global.Lobby.lobbyPeers.ToList());
    }
}

[MessagePackObject]
public struct RPCMessage
{
    [Key(0)]
    public string nodePath;

    [Key(1)]
    public string methodName;

    [Key(2)]
    public byte[] data;
}